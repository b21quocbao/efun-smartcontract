// SPDX-License-Identifier: UNLICENSED

pragma solidity =0.8.4;
pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@chainlink/contracts/src/v0.8/KeeperCompatible.sol";
import "./EDataTypes.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@chainlink/contracts/src/v0.8/ChainlinkClient.sol";
import "@chainlink/contracts/src/v0.8/ConfirmedOwner.sol";

import "hardhat/console.sol";

contract Event is OwnableUpgradeable, KeeperCompatibleInterface, ChainlinkClient, ConfirmedOwner {
    mapping(uint256 => EDataTypes.Event) public events;
    uint256 public nEvents;
    uint256 private fee;

    function initialize() public initializer ConfirmedOwner(msg.sender) {
        nEvents = 0;
        fee = (1 * LINK_DIVISIBILITY) / 10;
        OwnableUpgradeable.__Ownable_init();
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function updateEventResult(uint256 _eventId, uint256 _index) external {
        EDataTypes.Event storage _event = events[_eventId];
        require(_index < _event.odds.length, "cannot-find-index");
        require(_event.creator == msg.sender, "unauthorized");
        require(_event.endTime <= block.timestamp, "end_time <= timestamp");
        require(_event.endTime + 86400 >= block.timestamp, "end_time + 2 days >= timestamp");

        _event.resultIndex = _index;
        _event.status = EDataTypes.EventStatus.FINISH;

        emit EventResultUpdated(msg.sender, _eventId, _index);
    }

    /* ========== PUBLIC FUNCTIONS ========== */

    function info(uint256 _eventId) external view returns (EDataTypes.Event memory _event) {
        _event = events[_eventId];
    }

    function createSingleEvent(
        uint256 _startTime,
        uint256 _deadlineTime,
        uint256 _endTime,
        address _helperAddress,
        uint256[] calldata _odds,
        string memory _datas,
        address _creator
    ) external returns (uint256 _idx) {
        require(_startTime < _deadlineTime, "deadline_time > start_time");
        require(_deadlineTime < _endTime, "end_time > deadline_time");
        _idx = nEvents;

        events[_idx] = EDataTypes.Event(
            _startTime,
            _deadlineTime,
            _endTime,
            0,
            EDataTypes.EventStatus.AVAILABLE,
            _helperAddress,
            _creator,
            _odds,
            _datas
        );
        emit EventCreated(_idx, _startTime, _deadlineTime, _endTime, _helperAddress, _creator, _odds, _datas);
        nEvents++;
    }

    /* ========== CHAIN LINK FUNCTIONS ========== */

    function toBytes(uint256 x) internal pure returns (bytes memory b) {
        b = new bytes(32);
        assembly {
            mstore(add(b, 32), x)
        }
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    ) public view override returns (bool upkeepNeeded, bytes memory performData) {
        string memory performString;
        for (uint256 i = 0; i < nEvents; ++i) {
            if (events[i].endTime <= block.timestamp && events[i].status == EDataTypes.EventStatus.AVAILABLE) {
                upkeepNeeded = true;
                performString = string(bytes.concat(bytes(performString), bytes(Strings.toString(i)), " "));
            }
        }
        performData = bytes(performString);
    }

    /**
     * @notice Fulfillment function for multiple parameters in a single request
     * @dev This is called by the oracle. recordChainlinkFulfillment must be used.
     */
    function fulfill(
        bytes32 requestId,
        string memory response
    ) public recordChainlinkFulfillment(requestId) {
        console.log(response);
    }

    function performUpkeep(bytes calldata performData) public override {
        uint256 number = 0;

        for (uint256 i = 0; i < performData.length; i++) {
            uint8 c = uint8(performData[i]);
            if (c >= 48 && c < 58) {
                number = number * 10 + c - 48;
            } else {
                Chainlink.Request memory req = buildChainlinkRequest(
                    jobId,
                    address(this),
                    this.fulfill.selector
                );
                req.add("urlBTC", "https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=BTC", "");
                req.add("pathBTC", "BTC");
                sendChainlinkRequest(req, fee);
                events[number].resultIndex = 1;
                events[number].status = EDataTypes.EventStatus.FINISH;
                number = 0;
            }
        }
    }

    function combine(bytes calldata checkData) public {
        bool upkeepNeeded;
        bytes memory performData;
        (upkeepNeeded, performData) = checkUpkeep(checkData);
        if (upkeepNeeded) {
            this.performUpkeep(performData);
        }
    }

    /* =============== EVENTS ==================== */

    event EventResultUpdated(address caller, uint256 eventId, uint256 index);
    event EventCreated(
        uint256 idx,
        uint256 startTime,
        uint256 deadlineTime,
        uint256 endTime,
        address helperAddress,
        address creator,
        uint256[] odds,
        string datas
    );
}
